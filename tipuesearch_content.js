var tipuesearch = {"pages":[{"title":"对Python中super的理解","text":"前言 以前一直以为super就是调用父类方法嘛, 直到最近回顾了Python的MRO才发觉没这么简单, super并不是调用父类的方法, 而是调用了MRO中下一个类的方法. 环境: Python3.6 单继承 在单继承中 super 就像我以前理解的那样, 主要用来调用父类方法: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class A : def __init__ ( self ): self . n = 2 def add ( self , m ): print ( 'self is {0} @A.add' . format ( self )) self . n += m class B ( A ): def __init__ ( self ): self . n = 3 def add ( self , m ): print ( 'self is {0} @B.add' . format ( self )) super () . add ( m ) self . n += 3 b = B () b . add ( 2 ) print ( b . n ) 执行结果如下: 1 2 3 self is < __main__ . B object at 0x106c49b38 > @B.add self is < __main__ . B object at 0x106c49b38 > @A.add 8 之前在别的教程看到说 super 会找到当前类的父类, 然后将实例转换为父类实例, 但是从上面例子可以看到并不是这样, 实例一直都是当前类的实例, 所以结果是 8 而不是 7 多继承 我们用菱形继承关系来举例说明多继承中的 super : 代码如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class A : def __init__ ( self ): self . n = 2 def add ( self , m ): print ( 'self is {0} @A.add' . format ( self )) self . n += m class B ( A ): def __init__ ( self ): self . n = 3 def add ( self , m ): print ( 'self is {0} @B.add' . format ( self )) super () . add ( m ) self . n += 3 class C ( A ): def __init__ ( self ): self . n = 4 def add ( self , m ): print ( 'self is {0} @C.add' . format ( self )) super () . add ( m ) self . n += 4 class D ( B , C ): def __init__ ( self ): self . n = 5 def add ( self , m ): print ( 'self is {0} @D.add' . format ( self )) super () . add ( m ) self . n += 5 d = D () d . add ( 2 ) print ( d . n ) 这次的输出如下: 1 2 3 4 5 self is < __main__ . D object at 0x10ce10e48 > @D.add self is < __main__ . D object at 0x10ce10e48 > @B.add self is < __main__ . D object at 0x10ce10e48 > @C.add self is < __main__ . D object at 0x10ce10e48 > @A.add 19 让我们来看看这是怎么发生的, 为什么结果是 19 . 首先要明确的是: 类D的MRO为 D->B->C->A' , 可以通过 D.__mro__ 查看 super并不会进行实例转换, 这里的实例一直是类D的实例, 上面输出可以看出. 既然实例一直没变, 那么A, B, C类add方法中的self.n其实也就是d.n了. python3中D类的 super().add(m) 等价于 super(D, self).add(m) , 这点下一小节会用到. 当我们调用 d.add(2) , 执行到D中add方法中的super的时候, super会通过MRO找到类D的下一类, 也就是类B. 执行到B中add方法中的super, super又通过原先的那个MRO(因为实例一直是类D的实例, 所以也就是类D的MRO)找到类B的下一个类( 这里要注意的是super并不是找到B的父类 ), 也就是类C, 依次类推, 最终结果便是 19 了 super其实是个类 没错, super是个类而不是函数, 当我们调用 super() 的时候实际上是实例化了一个 super 类, 它包含了两个重要的信息: 一个MRO以及MRO中的一个类. super() 接收两个参数, 当我们这样调用时: super ( a_type , obj ) 实例化的super类会保存 type(obj) 的MRO, 同时 isinstance(obj, a_type)==True 判断obj为a_type类型(想象一下, 如果是False那么type(obj)的MRO中根本找不到a_type), 然后从MRO中a_type后面开始搜索, 用上面的代码举例说明一下可能会更方便理解. 当我们执行到 类D 的 super().add(m) 的时候(其实等价于 super(D, self).add(m) ), 实例化的super类会保存type(self)的MRO(type(self)==Class D, D的MRO为 D->B->C->A ), 同时 isinstance(self, D)==True , 然后从MRO中D后面可以搜索, 也就是 B->C-A . super还可以这样调用: super ( type1 , type2 ) super类会保存type2的MRO, 然后从MRO中type1后面可以搜索, 同时 issubclass(type2, type1)==True 判断type2是否是type1的子类, 按上面的代码举个例子, 调用: super ( C , D ). add ( m ) D的MRO为 D->B->C->A , 那么上述调用只会从 C 后面找, 也就是只能从 A 中找","tags":"Python","url":"/blog/2019_09_09/python-super.html"},{"title":"对Python中多继承的MRO的理解","text":"什么是函数解析顺序(MRO)? 方法解析顺序(MRO, Method-Resolution-Roder)定义了Python多继承的情况下, 解释器查找函数解析的具体顺序. Python各版本中的MRO 在2.2版本以前只有经典类(Old-style Class), 类使用深度优先搜索(DFS, Depth-First-Search). 在2.2版本引入新式类(New-style Class), 经典类还是使用DFS, 新式类则使用广度优先算法(BFS, Breadth-First-Search), BFS仅在2.2版本中使用过. 在2.2版本以后python 3版本以前, 新式类采用C3线性化算法, 经典类采用深度优先算法. python 3以后类都是新式类, 使用C3线性化算法. 总结: 经典类都是DFS算法, 新式类除了在2.2版本中使用过BFS算法, 其他版本都是C3算法. 先谈谈DFS和BFS 先看看以下菱形继承关系: B和C继承自A, D继承自B, C. 代码如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #python2中 Class A : def who ( self ): print 'I am class A' Class B ( A ): pass Class C ( A ): def who ( self ): print 'I am class C' Class D ( B , C ): pass d = D () d . who () #结果是'I am class A' 按照DFS算法, 解析顺序是 D->B->A->C->A , 之前解析过的类A不会再解析, 所以最终是 D->B->A->C . 这样会出现什么问题呢? 你可以在C类中重写其父类A中的方法, 但是你永远访问不到你重写的方法, 因为解析到A就找到了, 所以这就是经典类使用DFS算法的缺陷. 再来说说2.2版本中新式类使用的BFS算法, 还是根据上图的菱形继承关系, 解析顺序是 D->B->C->A , BFS算法解决了经典类中DFS子类无法重写父类的问题, 但是这又引起了另一个问题, 看看正常的继承方式: 代码如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #环境为python2.2 Class A ( object ): def who ( self ): print 'I am class A' Class B ( object ): pass Class C ( A ): pass Class D ( B ): def who ( self ): print 'I am class D' Class E ( C , D ): pass e = E () e . who () #结果应该是'I am class D', 这里我没装2.2版本的, 但应该是这样, 有兴趣的可以测试下. 我们在类A和类D中实现同一个方法. 按照2.2版本新式类的BFS算法, 解析顺序是 E->C->D->A->B . 这里A类是C类的唯一父类, 这种情况应该从唯一父类中找, 但BFS算法却先找到D类中的方法, 这样违背了单调性原则, 所有BFS仅存在于2.2一个版本. C3线性化算法 Python在2.3及之后版本的新式类都使用了C3线性化算法(C3 linearization), C3算法解决了DFS和BFS所不能解决的问题, 下面我将详细谈谈C3算法. 这里先给不想看算法计算过程的小伙伴一个方便的C3算法解析过程: 按照上面的菱形继承关系图, 我们先用深度优先遍历得到MRO为 D->B->A->C->A(先别把最后的A去掉) , 然后我们看到 D->B->A->C->A 中的第一个A在后面出现过, 我们就把这个A去掉, 最终的MRO就是 D->B->C->A . 这个就是C3算法得出的MRO. 也就是说, 对于多继承关系, 先用深度优先遍历(先不把解析过的去掉)得到一个MRO, 然后再根据这个MRO从左往右遍历, 只要当前的类出现在后面, 我们就把当前的类删掉, 也就是说对于重复出现的类我们只保留它的最后一个位置, 最终得到的就是C3算法得出的MRO了. C3线性化算法的计算过程 下面讲讲C3算法的计算过程. 介绍算法前首先约定需要使用的符号. 用 \\([C_1C_2C_3\\cdots C_N]\\) 来表示包含N个类的列表, 并令 $$ head([C_1C_2C_3 \\cdots C_N]) = [C_1] %就是取第一个 $$ $$ tail([C_1C_2C_3 \\cdots C_N]) = [C_2C_3\\cdots C_N] %就是去掉第一个 $$ $$ [C_1] + [C_2C_3 \\cdots C_N] = [C_1C_2 \\cdots C_N] $$ 也就是 \\(head()\\) 取里面第一个, \\(tail\\) 取除了第一个. 假设类 \\(C\\) 继承自父类 \\(B_1,\\cdots,B_N\\) , 那么根据C3线性化算法, 类 \\(C\\) 的解析列表通过以下公式决定: $$ L[C(B_1B_2 \\cdots B_N)] = [C] + merge(L[B_1], L[B_2], \\cdots, L[B_N], B_1, B_2, \\cdots , B_N) $$ 说明一下, \\(merge\\) 公式左部分是类 \\(C\\) 的所有父类的解析列表( \\(L[B_1]\\) 表示类 \\(B_1\\) 的解析列表), 也就是每个父类的解析列表. 右部分是类 \\(C\\) 的所有父类. 所以这个公式表明 \\(C\\) 的解析列表是通过对其父类的解析列表和其父类做 \\(merge\\) 操作得到的, 那么接下来就介绍重点的 \\(merge\\) , 分为以下步骤: 取 \\(merge\\) 中的第一个列表记为当前列表 \\(K\\) . (相当于取类C的第一个父类的解析列表) 令 \\(h = head(K)\\) , 如果 \\(h\\) 没有出现在其他任何列表的 \\(tail\\) 中,就将其加入 \\(C\\) 的解析列表中,并将其从 \\(merge\\) 中所有地方移除(包括列表和类), 之后重复步骤2. 否则,设置 \\(K\\) 为 \\(merge\\) 中的下一个列表, 并重复2中的操作. 如果 \\(merge\\) 中所有类都被移除, 则创建类成功; 如果不能找到下一个 \\(h\\) , 则拒绝创建类并抛出异常. 举例说明上述步骤, 假设有以下的类继承关系: 1 2 3 4 5 6 7 #python3环境 #交叉继承, 会抛异常 class X : pass class Y : pass class A ( X , Y ): pass class B ( Y , X ): pass class F ( A , B ): pass 首先有 \\(L[X] = [X]\\) , \\(L[Y] = [Y]\\) , 然后可以得到: $$ L[A] = [A] + merge(L[X], L[Y], X, Y) = [A, X, Y] $$ $$ L[B] = [B] + merge(L[Y], L[X], Y, X) = [B, Y, X] $$ 根据公式: $$ L[F(A, B)] = [F] + merger(L[A], L[B], A, B) = [F] + merge([A, X, Y], [B, Y, X], A, B) $$ 按1, 2步骤有 \\(K = L[A]\\) , \\(h = head(L[A]) = A\\) , 判断到 \\(A\\) 不在其他任何列表的 \\(tail\\) 中( \\(tail([B, Y, X]) = [Y, X]\\) ), 于是我们将 \\(A\\) 加入到类 \\(F\\) 的解析列表中(同时将A从所有列表中删除), 得到: $$ L[F] = [F, A] + merge([X, Y], [B, Y, X], B) $$ 按照步骤2, 此时 \\(K = L[A] = L[X, Y]\\) (上一步已将A移除), \\(h = head(K) = X\\) , 此时发现 \\(X\\) 不满足要求 ( \\(X\\) 出现在 \\(tail([B, Y, X]) = [Y, X]\\) 中), 根据步骤3令 \\(K = [B, Y, X]\\) , \\(h = head(K) = B\\) , \\(B\\) 满足要求因此将 \\(B\\) 加入到C的解析列表中并将其中 \\(merge\\) 中所有地方移除, 得到: $$ L[F] = [F, A, B] + merge([X, Y], [Y, X]) $$ 继续步骤2, 当前 \\(K = [Y, X]\\) (上一步已将B删除), \\(h = head(K) = Y\\) , 显然 \\(Y\\) 不满足要求, 由于 \\(merge\\) 没有下一个列表了, 所以无法继续选择 \\(h\\) , 根据步骤4, 类F创建失败并抛出异常. 来自wiki的更为复杂的继承例子 代码如图: 1 2 3 4 5 6 7 8 9 10 11 12 #python3环境 class O : pass class C ( O ): pass class A ( O ): pass class B ( O ): pass class D ( O ): pass class E ( O ): pass class K1 ( C , A , B ): pass class K3 ( A , D ): pass class K2 ( B , D , E ): pass class Z ( K1 , K3 , K2 ): pass print ( Z . __mro__ ) #输出的mro与下面结论一样 按照我们上面的C3算法解析过程, 先深度遍历再取重复的类最后的位置, Z的MRO先深度遍历是: Z->K1->C->O->A->O->B->O->K3->A->O->D->O->K2->B->O->D->O->E->O . 对于重复出现的类只保存最后的位置, 所以最终Z的MRO顺序应该是: Z->K1->C->K3->A->K2->B->D->E->O 我们再通过计算过程验证下看看是不是这样: $$ L[O] = [O] $$ $$ L[C(O)] = [C] + merge(L[O], O) = [C, O] $$ $$ L[A(O)] = [A] + merge(L[O], O) = [A, O] $$ $$ L[B(O)] = [B] + merge(L[O], O) = [B, O] $$ $$ L[D(O)] = [D] + merge(L[O], O) = [D, O] $$ $$ L[E(O)] = [E] + merge(L[O], O) = [E, O] $$ 上面的结果比较容易得到. $$ \\begin{align} L[K1(C, A, B)] &= [K1] + merge(L[C], L[A], L[B], C, A, B) \\\\ &= [K1] + merge([C, O], [A, O], [B, O], C, A, B)\\\\ &= [K1, C] + merge([O], [A, O], [B, O], A, B)\\\\ &= [K1, C, A] + merge([O], [O], [B, O], B)\\\\ &= [K1, C, A, B] + merge([O], [O], [O])\\\\ &= [K1, C, A, B, O] \\end{align} $$ $$ \\begin{align} L[K3(A, D)] &= [K3] + merge(L[A], L[D], A, D) \\\\ &= [K3] + merge(L[A, O], L[D, O], A, D)\\\\ &= [K3, A] + merge([O], L[D, O], D)\\\\ &= [K3, A, D] + merge([O], [O])\\\\ &= [K3, A, D, O] \\end{align} $$ $$ \\begin{align} L[K2(B, D, E)] &= [K2] + merge(L[B], L[D], L[E], B, D, E) \\\\ &= [K2] + merge([B, O], [D, O], [E, O], B, D, E)\\\\ &= [K2, B] + merge([O], [D, O], [E, O], D, E)\\\\ &= [K2, B, D] + merge([O], [O], [E, O], E)\\\\ &= [K2, B, D, E] + merge([O], [O], [O])\\\\ &= [K2, B, D, E, O] \\end{align} $$ 所以最终Z的MRO列表为: $$ \\begin{align} L[Z(K1, K3, K2] &= [Z] + merge(L[K1], L[K3], L[K2], K1, K3, K2)\\\\ &= [Z] + merge([K1, C, A, B, O], [K3, A, D, O], [K2, B, D, E, O], K1, K3, K2) \\\\ &= [Z, K1] + merge([C, A, B, O], [K3, A, D, O], [K2, B, D, E, O], K3, K2)\\\\ &= [Z, K1, C] + merge([A, B, O], [K3, A, D, O], [K2, B, D, E, O], K3, K2)\\\\ &= [Z, K1, C, K3] + merge([A, B, O], [A, D, O], [K2, B, D, E, O], K2)\\\\ &= [Z, K1, C, K3, A] + merge([B, O], [D, O], [K2, B, D, E, O], K2)\\\\ &= [Z, K1, C, K3, A, K2] + merge([B, O], [D, O], [B, D, E, O])\\\\ &= [Z, K1, C, K3, A, K2, B] + merge([O], [D, O], [D, E, O])\\\\ &= [Z, K1, C, K3, A, K2, B, D] + merge([O], [O], [E, O])\\\\ &= [Z, K1, C, K3, A, K2, B, D, E] + merge([O], [O], [O])\\\\ &= [Z, K1, C, K3, A, K2, B, D, E, O] \\end{align} $$ 最终得到的结果与我们上面得出的一致. if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; var configscript = document.createElement('script'); configscript.type = 'text/x-mathjax-config'; configscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" availableFonts: ['STIX', 'TeX'],\" + \" preferredFont: 'STIX',\" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'ForestGreen ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript); (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Python","url":"/blog/2019_09_08/python-mro.html"},{"title":"Github Page和Pelican搭建个人博客,并使用主题Elegant","text":"前言 什么是 Github Pages , Pelican 和 elegant ? Github pages允许你存放你的静态博客, Pelican是基于Python的, 能让你迅速创建博客骨架, elegant是一款Pelican主题. 效果预览 最近想搭建个博客网站写一些东西，最终选择了在Github上写博客, 今天刚把博客搭建完, 写一下搭建的过程还有遇到的一些问题和解决方法． 个人环境: Ubuntu 18.04, Python3.6 一. 创建Github Pages 这一步很简单, 在Github上新建个repository, name可以写作username.github.io, 比如我的是huangjiarong.github.io, 然后公开创建就可以了.参考官方网站 Github Pages 二. 安装Pelican 使用虚拟环境, 这里我用的virtualenvwrapper mkvirtualenv pelican 安装Pelican, 使用Markdown写文章的话还得安装Markdown pip install pelican pip install markdown 三. 使用Pelican 新建目录 myBlog , 然后进入目录快速创建博客 mkdir myBlog cd myBlog pelican - quickstart 执行完 pelican-quickstart 后, 会提示你输入一些博客的配置, 大多数可直接回车选择默认, 后续这些配置都可以在 pelicanconf.py 文件中修改. 执行完后的目录是这样的: blog / ├── content # 存放文章内容 ├── Makefile ├── output # 存放静态页面 ├── pelicanconf . py # 配置文件 ├── publishconf . py # 发布时的配置 └── tasks . py 接下来在 content 目录下写个 blog.md 文件,内容如下: Title : My First Blog Date : 2019 - 01 - 01 Category : Blog Slug : first My first blog . 保存,然后执行 make html 进入 output 文件夹就可以看到pelican为我们生成的html静态文件, 执行 make serve 就可以在本地 127.0.0.1:8000 查看效果, 不过默认主题不好看, 后续将会采用elegant主题, 现在先修改一下配置文件, 因为我想修改一下文章的保存路径还有url, 不然的话当文章一多的话看起来 output 文件夹会很乱, 而且不好管理. 在 pelicanconf.py 文件加入以下变量: ARTICLE_PATHS = [ 'blog' ] ARTICLE_SAVE_AS = 'blog/{date:%Y_%m_%d}/{slug}.html' ARTICLE_URL = 'blog/{date:%y_%m_%d}/{slug}.html' 然后在 content 目录下新建 blog 目录, 以后文章写在 blog 目录下, 执行 make html 后生成的文章主页将在 output/blog 文件夹下, 按日期进行分类. url也将随之改变为 blog/2019_01_01/first.html , 当然前提是以后在md文件中写上Date和Slug元信息. 每次写文章都得 make html 然后 make serve 查看效果, Pelican官方文档 提供了另一种方法 make devserver 可以将两个命令结合起来, 这样每次修改文章后保存直接刷新浏览器就能查看效果了. 四. 使用Elegant主题 Pelican默认的主题不好看, 这里我使用了Elegant主题. 在github上下载主题, 在这里我把主题放到了 myBlog 目录下, 也就是 content 的同级目录 git clone --recursive https://github.com/getpelican/pelican-themes 下载完后在 pelicanconf.py 添加 THEME = 'pelican-themes/elegant' 然后 make html , make serve 就能查看主题效果了, 这里还得配置一些主题的功能. 4.1 增加Contents 效果是该篇博客最左边的Contents这样, 参考 elegant官方文档 , 首先我们需要下载一些插件, 可以从github上获取, 这里我将插件放在 myBlog 目录下, 和 content , pelican-themes 等目录同级, 在 myBlog 目录使用以下命令: git clone --recursive https://github.com/getpelican/pelican-plugins 然后在 pelicanconf.py 加入: PLUGIN_PATHS = [ \"pelican-plugins\" ] PLUGINS = [ 'extract_toc' , ] 然后在.md文件中使用 [TOC] 就可以了. Title : My First Blog Date : 2019 - 01 - 01 Category : Blog Slug : first [ TOC ] ### My first blog . 4.2 增加文章底部上一篇下一篇功能 参考 elegant官方文档 , 插件我们都下载了, 在修改 pelicanconf.py 的PLUGINS就行了 PLUGINS = [ 'extract_toc' , 'neighbors' , ] 4.3 全局搜索功能 参考 elegant官方文档 , 修改pelicanconf.py PLUGINS = [ 'extract_toc' , 'neighbors' , 'tipue_search' ] DIRECT_TEMPLATES = [ 'index' , 'authors' , 'categories' , 'tags' , 'archives' , 'search' ] 在这里我遇到了点问题, 首先是 DIRECT_TEMPLATES 要像我写的那样, 不然你只写了search的话, 你修改了md文件里的信息后执行完 make html , 你会发现 output 里的 index.html , tags 之类的都没更新, 也就是说这些文件都不会执行更新, 因为你没写进 DIRECT_TEMPLATES 里. 其次是搜索功能是依赖于google api的jquery的, 谷歌嘛在国内意味着得科学上网, 所以要用搜索功能的话我的方法是网上下载一份2.0版本的 jquery.min.js 文件, 然后放到 pelican-themes/elegant/static/tipuesearch 目录下, 然后修改 pelican-themes/elegant/templates/search.html 文件, 将里面链接到googleapi的jquery文件地址修改到我们下载的jquery文件地址: <script src= \" {{ SITEURL }} /theme/tipuesearch/jquery.min.js\" ></script> 这样搜索功能就完成了. 五. 上传到Github pages 进入 output 文件夹, 依次执行 git init git add . git remote add origin https : // github . com / your_username / your_username . github . io git pull origin master git commit - m 'first blog' git push origin master 进入 https://your_username.github.io 就能看到你的博客了.","tags":"Pelican","url":"/blog/2019_09_04/create-blog.html"}]};